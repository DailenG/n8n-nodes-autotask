# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Documentation Files

## Autotask API Documentation
Located in `/docs/autotask`.

### About REST API
- `about-rest-api/01.rest-api-latency.md` - Performance and latency considerations for API
- `about-rest-api/02.recurring-service-contract-entity-relationships.md` - Contract relationships guide
- `about-rest-api/03.security-and-auth.md` - Authentication and security protocols
- `about-rest-api/04.api-best-practices.md` - Best practices for API implementation

### API Calls
- `api-calls/01.introduction-rest-api.md` - Core concepts and getting started guide
- `api-calls/02.find-resource-and-child-access-urls.md` - Resource URL navigation guide
- `api-calls/03.basic-query-calls.md` - Fundamental query operations tutorial
- `api-calls/04.advanced-query-calls.md` - Complex query patterns and features
- `api-calls/05.entityInformation.md` - Entity information retrieval guide
- `api-calls/06.querying-user-zone-information.md` - User zone data access guide
- `api-calls/07.creating-via-post.md` - Resource creation via POST methods
- `api-calls/08.updating-via-patch.md` - Partial updates using PATCH
- `api-calls/09.updating-via-put.md` - Full updates using PUT
- `api-calls/10.deleting.md` - Resource deletion guide
- `api-calls/11.attachments.md` - Handling file attachments

### API Entities
- `api-entities/01.rest-api-resources.md` - Available API resources overview
- `api-entities/02.UserDefinedFieldDefinitions.md` - Custom field definitions guide
- `api-entities/03.UserDefinedFieldListItems.md` - Custom field list items reference
- `api-entities/04.User-defined fields.md` - Working with custom fields

### Webhooks
- `webhooks/01.webhooks-intro.md` - Introduction to webhook functionality
- `webhooks/02.creating-webhook-overview.md` - Webhook creation guide
- `webhooks/03.EntityName-Webhooks.md` - Entity-specific webhook setup
- `webhooks/04.EntityName-WebhookFields.md` - Webhook field configuration
- `webhooks/05.EntityName-WebhookUdfFields.md` - Custom fields in webhooks
- `webhooks/06.EntityName-WebhookExcludedResources.md` - Resource exclusion guide
- `webhooks/07.Secret-key-ayload-verification.md` - Webhook security verification
- `webhooks/08.Webhooks-error-handling.md` - Error handling strategies
- `webhooks/09.WebhookEventErrorLogs.md` - Event error logging reference

## n8n Integration Documentation
Located in `/docs/n8n`
### Reference
- `n8n/reference/01.node-ui-elements.md` - UI component guidelines
- `n8n/reference/02.code-standards.md` - Coding standards and practices
- `n8n/reference/03.node-file-structure.md` - Node architecture overview
- `n8n/reference/04.node-codex-files.md` - Node documentation format
- `n8n/reference/05.credentials-files.md` - Credential management guide
- `n8n/reference/06.http-helpers.md` - HTTP request helper utilities
- `n8n/reference/07.paired-items.md` - Working with paired data items

### Base Files
- `n8n/reference/base-files/01.base-files.md` - Core file structure guide
- `n8n/reference/base-files/02.structure.md` - Base architecture overview
- `n8n/reference/base-files/03.standard-parameters.md` - Parameter configuration guide
- `n8n/reference/base-files/04.declarative-style-parameters.md` - Declarative parameter setup
- `n8n/reference/base-files/05.programmatic-style-parameters.md` - Programmatic parameter setup
- `n8n/reference/base-files/06.programmatic-style-execute-method.md` - Execution method guide

### Planning
- `n8n/reference/plan/01.node-types.md` - Node type specifications
- `n8n/reference/plan/02.choose-node-method.md` - Node method selection guide
- `n8n/reference/plan/03.node-ui-design.md` - UI design principles

# MCP Server Tools Usage

## Strategic Tool Selection

- **Sequential Thinking:**
  - Use for multi-step operations requiring careful planning.
  - Maintain operational context to enable course correction.
  - Begin with a higher number of total thoughts (e.g. 8â€“12) for complex tasks.
  - Use branching to explore alternative approaches and mark revisions when needed.
  - Set `needsMoreThoughts=true` when new complexities arise.

- **Web Research (via Brave Search):**
  - Always conduct initial broad searches, then follow with detailed research.
  - Validate technical approaches, error handling strategies, and best practices.
  - Cross-reference multiple reputable sources before implementation.

- **Puppeteer Operations:**
  - Use for intricate web interactions and testing.
  - Implement chained operations with robust error handling, waits, and retries.
  - Optimise memory by closing pages when done and reusing browser instances.

- **Server Memory (Knowledge Graph):**
  - Maintain complex relationships and operational context.
  - Create entities for major components and concepts.
  - Map dependencies and document architectural decisions.
  - Regularly clean up obsolete entities and update relationships.

### Sequential Thinking
- Use for operations requiring multiple steps
- Essential for maintaining operational context
- Helps break down large changes into manageable chunks
- Enables course correction and revision of approach
- Key usage patterns:
  * Start with higher total_thoughts for complex tasks (8-12)
  * Use branching for exploring alternative approaches
  * Mark revisions when changing previous decisions
  * Set needsMoreThoughts=true when discovering new complexity
  * Use as tactical memory during long operations

### Web Research (Brave Search)
- Always search before implementing complex features
- Research patterns:
  * Start with broad concept search
  * Follow up with specific implementation details
  * Look for recent discussions and solutions
  * Cross-reference multiple sources
  * Use for validating approach before major changes
- Key usage:
  * Technical implementation patterns
  * Error handling strategies
  * Best practices validation
  * Community solutions to similar problems

### Puppeteer Operations
- Use for complex web interactions and testing
- Strategic patterns:
  * Chain operations with proper error handling
  * Use screenshots for validation points
  * Implement waits and retries for stability
  * Maintain session context across operations
- Memory management:
  * Close pages when done
  * Reuse browser instances when possible
  * Clear large objects after operations
  * Monitor memory usage in long sessions

## Operational Guidelines

### For Moderate Changes (30-100 lines):
1. Start with sequential thinking (5-8 thoughts)
2. Research similar implementations
3. Plan key validation points
4. Execute with regular state checks

### For Large Changes (100+ lines):
1. Begin with comprehensive sequential thinking (10+ thoughts)
2. Extensive research phase
3. Break into sub-operations
4. Regular validation checkpoints
5. Maintain operational memory through scratchpad


# Lessons

1. Parameter Handling
   - Always use case-insensitive parameter name comparison
   - Centralize parameter name normalization logic
   - Handle ID field variations consistently (id, ID, Id)
   - Consider creating utility functions for common parameter operations
   - Document expected parameter formats in code comments
   - Check resource mapper schema for UI field state (removed flag)
   - Include all non-removed fields in updates, even if empty
   - Validate operation-specific required fields
   - Check IsQueryable and IsReadOnly flags before operations
   - Handle UDF fields consistently across operations

2. Parent-Child Relationships
   - Always specify parent type when initializing operations for child entities
   - Use consistent casing for parent ID parameters (e.g., projectID, companyID)
   - Handle parent-child URL construction in a centralized way
   - Validate both parent and child IDs before making API calls
   - Respect HTTP method requirements for parent context
   - Handle association updates via PATCH with correct payload format
   - Support both direct and indirect parent relationships
   - Validate parent chain for nested relationships

3. URL Construction
   - Centralize URL building logic
   - Handle pluralization consistently
   - Support various URL patterns (standard, child, query, UDF)
   - Maintain backward compatibility while improving code structure
   - Handle operation-specific URL patterns
   - Support both parent-less and parent-required endpoints
   - Implement consistent association endpoint patterns
   - Handle UDF-specific endpoint variations
   - ALWAYS use plural form for subname in entity definitions (e.g., 'Notes' not 'Note')
   - Verify endpoint patterns match proven implementations (e.g., Tasks)
   - Parent-child endpoints must follow pattern: /Parents/{parentId}/SubnameS/{id}
   - Direct query endpoints follow pattern: /EntityName/query

4. Error Handling
   - Provide clear error messages with attempted parameter variations
   - Include entity context in error messages
   - Use consistent error templates
   - Log debugging information when needed
   - Include operation-specific validation errors
   - Handle rate limiting and pagination errors
   - Provide clear association management error messages
   - Document API-specific error codes and meanings

5. Resource Mapper Handling
   - Check schema.removed flag to determine active fields
   - Include all non-removed fields in updates
   - Use empty string for fields without values
   - Preserve UI field state during updates
   - Support EntityDefinition endpoint integration
   - Handle operation-specific field requirements
   - Manage association field mappings
   - Support UDF field definitions

6. API Operation Patterns
   - Respect HTTP method requirements per operation type
   - Handle parent context requirements correctly
   - Support proper association management patterns
   - Implement efficient pagination and bulk operations
   - Handle rate limiting and caching appropriately
   - Support all required query patterns
   - IMPORTANT: Check API documentation and entity metadata for supported operations
   - Some entities may intentionally not support deletion (e.g., Project Phases) to maintain data integrity
   - Don't assume all CRUD operations are available for every entity
   - Use correct endpoints for field information:
     * Standard fields: /entityInformation/fields
     * UDF fields: /entityInformation/userDefinedFields
     * Entity metadata: /entityInformation
   - Handle nested response structures correctly:
     * Entity info is nested under "info" key: { "info": { ... } }
     * Fields are nested under "fields" key: { "fields": [ ... ] }
     * Always validate response structure before accessing properties

7. Advanced Query Operations
   - Always validate JSON filter structure before processing
   - Support all Autotask API filter operators (eq, noteq, gt, gte, lt, lte, contains, beginsWith, endsWith, exist, notExist, in, notIn, and, or)
   - Handle pagination limits (max 50 pages at a time)
   - Include Id field when results exceed 500 records
   - Support MaxRecords range of 1-500 per page
   - Maintain pagination context for next/previous page URLs
   - Don't modify MaxRecords or IncludeFields during pagination
   - Consider using strong filters to improve performance
   - Handle UDF fields in field inclusion
   - Document pagination limitations in code comments

8. Advanced Query Operation Patterns
   - Always validate JSON filter structure before processing
   - Support all Autotask API filter operators
   - Handle pagination limits consistently (max 50 pages, 500 records per page)
   - Validate operator compatibility with field types
   - Support nested logical conditions (and/or)
   - Implement robust error handling with clear messages
   - Follow entity info operation pattern for common operations
   - Use unified resource operation helper for consistency
   - Support UDF fields in advanced queries
   - Document filter structure and limitations

# Scratchpad

## Timezone Conversion Issue Analysis and Implementation Plan for Create and Update operations
<think>Let me review what we've learned and successfully implemented to fix the date conversion issues in the n8n-nodes-autotask integration. I'll organize this into a proper refactored implementation plan that reflects what we actually did, along with the lessons learned.

### Original Problem
The n8n-nodes-autotask integration was not properly handling date/time field conversion between the n8n UI format and the Autotask API's expected UTC format, particularly during update operations.

### Actual Implementation Steps Taken

1. **Identified the Core Issues**
   - Field type detection in the API response was unreliable - field definitions weren't correctly identifying date/time fields
   - The system needed to handle the n8n-specific date format (`YYYY-MM-DDTHH:mm:ss`)
   - Converters were not being consistently applied in the update workflow

2. **Enhanced Date Field Detection**
   - Added name-based pattern detection as a fallback when field type information is incorrect
   - Used field name patterns like "date", "time", and fields ending with "at" to identify potential date fields
   - Added detailed logging to diagnose field definition discrepancies

3. **Improved n8n Format Handling**
   - Added special case handling for the n8n UI format (`YYYY-MM-DDTHH:mm:ss`)
   - Implemented explicit format parsing with moment.js
   - Added checks for trailing 'Z' in date strings (indicating UTC)

4. **Enhanced Field Validator**
   - Modified the field validation process to detect date fields both by type and by name pattern
   - Added fallback conversion mechanisms when the primary date conversion fails
   - Improved error handling and diagnostic logging

5. **Additional Safeguards**
   - Implemented the field detection by naming pattern as a secondary mechanism
   - Added detailed logging throughout the conversion process
   - Ensured timezone configuration was consistently applied

### Key Lessons Learned

1. **Field Type Recognition**
   - Don't rely solely on field type definitions from the API; implement redundant detection mechanisms
   - Field naming conventions (contains "date", "time", etc.) can provide a reliable backup detector
   - Log and verify field definitions during development and in production

2. **Date Format Handling**
   - Explicitly handle known UI-specific formats (like n8n's `YYYY-MM-DDTHH:mm:ss`)
   - Use precise format specifiers with moment.js rather than relying on auto-detection
   - Handle timezone conversion explicitly at each step

3. **Defensive Programming**
   - Implement multiple conversion methods with fallbacks
   - Log detailed information about field types, values, and conversion attempts
   - Use pattern detection as a complement to metadata-based identification

4. **Timezone Management**
   - Always use the configured timezone consistently throughout the codebase
   - Convert to UTC for all API operations
   - Store timezone in credentials for consistent access

5. **Debugging Techniques**
   - Add comprehensive logging at each conversion stage
   - Log field definitions to verify what the API is actually providing
   - Implement diagnostic logging that shows before/after values for conversions

Let me organize this into a clean, refactored implementation plan that shows what we actually did to solve the problem.</think># Timezone Conversion Issue - Implementation Summary

## Problem Statement
We identified that the n8n-nodes-autotask integration wasn't consistently handling date/time fields, particularly during update operations. Date fields were not being properly converted between the n8n UI format and the Autotask API's expected UTC format.

## Actual Implementation

### 1. Implemented Robust Date Field Detection
- **Field Type Detection**: Created a dual detection system using both API field definitions and name-based pattern matching
- **Pattern-Based Fallback**: Added detection for field names containing "date", "time" or ending with "at"
- **Diagnostic Logging**: Added logging to identify discrepancies between API field types and actual data

### 2. Enhanced n8n Format Handling
- **Explicit Format Handling**: Added special case handling for n8n's specific date format (`YYYY-MM-DDTHH:mm:ss`)
- **Format-Specific Parsing**: Implemented explicit format parsing instead of relying on auto-detection
- **UTC Indicator Handling**: Added handling for trailing 'Z' in date strings (UTC indicator)

### 3. Added Fallback Conversion Methods
- **Multiple Conversion Paths**: Implemented primary and fallback conversion methods
- **Direct moment.js Conversion**: Added direct timezone conversion as a fallback
- **Better Error Reporting**: Improved error messages for conversion failures

## Key Lessons Learned

### 1. Field Type Recognition
- **Don't Trust API Types Alone**: API field definitions may be incorrect or incomplete
- **Implement Pattern Detection**: Use field naming patterns as a reliable backup detector
- **Verify Field Types**: Log and validate field types during development and in production

### 2. Date Format Handling
- **Handle Application-Specific Formats**: Explicitly handle known formats from the UI
- **Use Precise Format Specifiers**: Specify exact formats to moment.js rather than auto-detection
- **Timezone Awareness**: Always be explicit about timezone conversions at each step

### 3. Defensive Programming
- **Multiple Fallbacks**: Implement multiple methods with graceful degradation
- **Verbose Logging**: Add detailed logs about field types, values, and conversion results
- **Pattern Matching**: Use linguistic patterns in field names as a supplement to metadata

### 4. Validation Chain
- **Pre-Request Validation**: Ensure consistent validation before API requests
- **Centralized Format Conversion**: Consolidate date format handling in a single location
- **Clear Conversion Rules**: Document the format conversion rules explicitly

This implementation ensures more reliable date handling by adding multiple detection mechanisms and format-specific conversions, solving the inconsistent behavior we were experiencing with date/time fields in the Autotask integration.

## Query Operations Timezone Conversion Plan

### Problem Statement
While we've implemented robust timezone conversion for create and update operations (converting from user timezone to UTC), we now need to implement the reverse conversion for query operations - converting date/datetime fields from UTC (as returned by the API) to the user's configured timezone.

### Implementation Plan

1. **Reuse Existing Detection Mechanisms**
   - Leverage the dual detection system (field type and name pattern) we created for create/update
   - Apply the same date field identification logic when processing API responses

2. **Create Reverse Conversion Function**
   - Implement `convertUTCToUserTimezone` utility function
   - Include multiple conversion paths with fallbacks for robustness
   - Handle various date formats and edge cases consistently

3. **Process Query Responses**
   - Identify where API responses are processed after query operations
   - Create a response processor function that:
     * Iterates through response objects (handling arrays and nested objects)
     * Applies date detection to identify date fields
     * Converts identified fields from UTC to user timezone
     * Preserves original values if conversion fails

4. **Integration and Testing**
   - Integrate the processor function into the query workflow
   - Add diagnostic logging to track conversion operations
   - Test with various date formats and edge cases
   - Verify consistent behavior across different entity types

This approach maintains consistency with our existing implementation while addressing the specific requirements for query operations. It reuses existing code patterns where possible and implements the minimal changes needed to support the reverse conversion direction.

